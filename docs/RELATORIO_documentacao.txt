================================================================================
                    RELATÓRIO TÉCNICO - HORUS AI
                    Sistema de Monitoramento Inteligente de Vídeo
================================================================================
                    Documento elaborado para: Supervisão
                    Data: Dezembro/2025
================================================================================


================================================================================
TÓPICO 1: O QUE FOI IMPLANTADO E O QUE PODE SER IMPLEMENTADO NO FUTURO
================================================================================

------------------------------------------------------------------------------
1.1 O QUE JÁ FOI IMPLANTADO (FUNCIONALIDADES ATUAIS)
------------------------------------------------------------------------------

O Horus AI é um sistema completo de monitoramento de vídeo em tempo real que 
utiliza Inteligência Artificial para detectar problemas automaticamente.

FUNCIONALIDADES PRINCIPAIS IMPLEMENTADAS:

    ┌─────────────────────────────────────────────────────────────────────┐
    │  INGESTÃO DE STREAMS (Recebimento de Vídeo)                         │
    ├─────────────────────────────────────────────────────────────────────┤
    │  • Recebe streams de vídeo via protocolo SRT (seguro e confiável)   │
    │  • Converte automaticamente para HLS (formato web)                  │
    │  • Permite visualização em navegador sem plugins                    │
    │  • Funciona com streams instáveis (tolerância a erros)              │
    └─────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────┐
    │  ANÁLISE DE VÍDEO COM IA                                            │
    ├─────────────────────────────────────────────────────────────────────┤
    │  Modelo: "Odin v4.5" - Detecta problemas visuais:                   │
    │  • Normal       → Vídeo funcionando corretamente                    │
    │  • Freeze       → Imagem congelada                                  │
    │  • Fade         → Tela escurecendo/clareando anormalmente           │
    │  • Fora de Foco → Imagem borrada/desfocada                          │
    └─────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────┐
    │  ANÁLISE DE ÁUDIO COM IA                                            │
    ├─────────────────────────────────────────────────────────────────────┤
    │  Modelo: "Heimdall Ultra V1" - Detecta problemas de áudio:          │
    │  • Normal         → Áudio funcionando corretamente                  │
    │  • Ausência Áudio → Sem som (silêncio total)                        │
    │  • Eco/Reverb     → Áudio com eco ou reverberação                   │
    │  • Ruído/Hiss     → Chiado ou ruído de fundo                        │
    │  • Sinal Teste    → Tom de teste (beep contínuo)                    │
    └─────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────┐
    │  ANÁLISE DE SINCRONIA LABIAL (LIPSYNC)                              │
    ├─────────────────────────────────────────────────────────────────────┤
    │  Modelo: "SyncNet v2" - Detecta dessincronização áudio/vídeo:       │
    │  • Sincronizado     → Lábios e áudio alinhados                      │
    │  • Dessincronizado  → Áudio atrasado ou adiantado                   │
    │  • Sem Fala         → Não há pessoa falando no vídeo                │
    └─────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────┐
    │  INTERFACE WEB (FRONTEND)                                           │
    ├─────────────────────────────────────────────────────────────────────┤
    │  • Dashboard de Monitoramento em tempo real                         │
    │  • Player de vídeo integrado (HLS)                                  │
    │  • Gráficos de ocorrências (pizza, barras, linha do tempo)          │
    │  • Alertas visuais instantâneos via WebSocket                       │
    │  • Página de Dados com estatísticas históricas                      │
    │  • Página de Configurações do sistema                               │
    │  • Página de Cortes/Clips gerados                                   │
    └─────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────┐
    │  GERAÇÃO AUTOMÁTICA DE CLIPS                                        │
    ├─────────────────────────────────────────────────────────────────────┤
    │  • Quando detecta um problema, grava automaticamente um clip        │
    │  • Salva o trecho do vídeo como evidência (.mp4)                    │
    │  • Permite download e revisão posterior                             │
    └─────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────┐
    │  ANÁLISE DE ARQUIVOS (UPLOAD)                                       │
    ├─────────────────────────────────────────────────────────────────────┤
    │  • Upload de vídeos gravados para análise offline                   │
    │  • Diagnóstico completo frame a frame                               │
    │  • Relatório JSON com todas as métricas                             │
    └─────────────────────────────────────────────────────────────────────┘

------------------------------------------------------------------------------
1.2 O QUE PODE SER IMPLEMENTADO NO FUTURO (ROADMAP)
------------------------------------------------------------------------------

MELHORIAS DE CURTO PRAZO (1-3 meses):

    • Retry Automático: Reconectar automaticamente quando o stream cair
    • Limpeza Automática: Limpar clips antigos para economizar espaço
    • Configuração Dinâmica: Ajustar sensibilidade da IA via interface
    • Notificações: Enviar alertas por e-mail ou Telegram
    • Exportação de Relatórios: Gerar PDF com resumo das ocorrências

MELHORIAS DE MÉDIO PRAZO (3-6 meses):

    • Multi-Stream: Monitorar vários canais simultaneamente
    • Reconhecimento de Faces: Detectar quando apresentador sai de cena
    • Detecção de Legendas: Verificar se legendas estão aparecendo
    • Detecção de Logos: Verificar se logotipo do canal está visível
    • API de Integração: Conectar com sistemas de automação de TV

MELHORIAS DE LONGO PRAZO (6-12 meses):

    • Dashboard Multi-Usuário: Diferentes perfis de acesso
    • Histórico Completo: Banco de dados com anos de histórico
    • Machine Learning Adaptativo: IA que aprende com correções do usuário
    • Versão Mobile: App para monitoramento pelo celular
    • Integração com Playout: Ações automáticas (ex: trocar fonte)


================================================================================
TÓPICO 2: EVOLUÇÃO DO PROJETO E FERRAMENTAS UTILIZADAS
================================================================================

------------------------------------------------------------------------------
2.1 LINHA DO TEMPO DA EVOLUÇÃO
------------------------------------------------------------------------------

FASE 1 - FUNDAÇÃO (Estrutura Básica)
├── Criação da estrutura de pastas (backend/frontend)
├── Configuração do ambiente Python com FastAPI
├── Configuração do ambiente Angular 19
├── Integração básica com FFmpeg para processar vídeo
└── Primeira versão do player HLS

FASE 2 - INTEGRAÇÃO DE IA (Modelos de Machine Learning)
├── Integração do modelo de vídeo (Keras/TFLite)
├── Integração do modelo de áudio (TFLite)
├── Implementação do pipeline de inferência
├── Sistema de buffer deslizante para sequências temporais
└── Suporte a modelos 4D e 5D automaticamente

FASE 3 - INTERFACE E TEMPO REAL
├── Dashboard de monitoramento com gráficos ApexCharts
├── WebSocket para alertas em tempo real
├── Sistema de geração automática de clips
├── Página de histórico de ocorrências
└── Tema escuro e responsividade

FASE 4 - ROBUSTEZ E PRODUÇÃO
├── Tratamento de erros de stream (flags tolerantes FFmpeg)
├── Fallback de áudio (librosa → ffmpeg)
├── Sistema de snapshot para evitar race conditions
├── Logs detalhados para debugging
└── Variáveis de ambiente para configuração

FASE 5 - MODELOS AVANÇADOS (Atual)
├── Modelo de Lipsync (SyncNet v2) para sincronia labial
├── Validação extensiva dos modelos (100% de acurácia)
├── Otimização de performance (GPU/CPU)
├── Documentação técnica completa
└── Preparação para deploy em produção

------------------------------------------------------------------------------
2.2 FERRAMENTAS E TECNOLOGIAS UTILIZADAS
------------------------------------------------------------------------------

    ╔═══════════════════════════════════════════════════════════════════════╗
    ║                         BACKEND (SERVIDOR)                            ║
    ╠═══════════════════════════════════════════════════════════════════════╣
    ║                                                                       ║
    ║  LINGUAGEM:                                                           ║
    ║  • Python 3.11+          → Linguagem principal do backend             ║
    ║                                                                       ║
    ║  FRAMEWORK WEB:                                                       ║
    ║  • FastAPI               → API REST rápida e moderna                  ║
    ║  • Uvicorn               → Servidor ASGI de alta performance          ║
    ║                                                                       ║
    ║  INTELIGÊNCIA ARTIFICIAL:                                             ║
    ║  • TensorFlow 2.20       → Framework de Machine Learning              ║
    ║  • Keras 3.12            → API de alto nível para redes neurais       ║
    ║  • TFLite                → Modelos otimizados para inferência leve    ║
    ║                                                                       ║
    ║  PROCESSAMENTO DE MÍDIA:                                              ║
    ║  • FFmpeg                → Conversão e processamento de vídeo/áudio   ║
    ║  • OpenCV (cv2)          → Manipulação de frames de vídeo             ║
    ║  • Librosa               → Análise de áudio (espectrogramas)          ║
    ║  • SoundFile             → Leitura de arquivos de áudio               ║
    ║                                                                       ║
    ║  BANCO DE DADOS:                                                      ║
    ║  • SQLAlchemy            → ORM para acesso ao banco                   ║
    ║  • PostgreSQL            → Banco de dados relacional (opcional)       ║
    ║                                                                       ║
    ╚═══════════════════════════════════════════════════════════════════════╝

    ╔═══════════════════════════════════════════════════════════════════════╗
    ║                         FRONTEND (INTERFACE)                          ║
    ╠═══════════════════════════════════════════════════════════════════════╣
    ║                                                                       ║
    ║  FRAMEWORK:                                                           ║
    ║  • Angular 19            → Framework para aplicações web              ║
    ║  • TypeScript            → JavaScript com tipagem estática            ║
    ║                                                                       ║
    ║  VISUALIZAÇÃO:                                                        ║
    ║  • ApexCharts            → Gráficos interativos e responsivos         ║
    ║  • HLS.js                → Player de vídeo HLS no navegador           ║
    ║                                                                       ║
    ║  COMUNICAÇÃO:                                                         ║
    ║  • HTTP/REST             → Chamadas de API tradicionais               ║
    ║  • WebSocket             → Comunicação em tempo real                  ║
    ║  • RxJS                  → Programação reativa para eventos           ║
    ║                                                                       ║
    ╚═══════════════════════════════════════════════════════════════════════╝

    ╔═══════════════════════════════════════════════════════════════════════╗
    ║                      INFRAESTRUTURA E FERRAMENTAS                     ║
    ╠═══════════════════════════════════════════════════════════════════════╣
    ║                                                                       ║
    ║  CONTROLE DE VERSÃO:                                                  ║
    ║  • Git                   → Versionamento de código                    ║
    ║  • GitHub                → Repositório remoto e colaboração           ║
    ║                                                                       ║
    ║  AMBIENTE DE DESENVOLVIMENTO:                                         ║
    ║  • VS Code               → Editor de código principal                 ║
    ║  • GitHub Copilot        → Assistente de IA para desenvolvimento      ║
    ║  • PowerShell            → Terminal para execução de comandos         ║
    ║                                                                       ║
    ║  STREAMING:                                                           ║
    ║  • SRT (Secure Reliable  → Protocolo de streaming profissional        ║
    ║    Transport)                                                         ║
    ║  • HLS (HTTP Live        → Formato de streaming para web              ║
    ║    Streaming)                                                         ║
    ║                                                                       ║
    ╚═══════════════════════════════════════════════════════════════════════╝

------------------------------------------------------------------------------
2.3 ARQUITETURA SIMPLIFICADA DO SISTEMA
------------------------------------------------------------------------------

                        ARQUITETURA HORUS AI
    
    ┌─────────────┐     ┌─────────────────────────────────────┐
    │   STREAM    │     │              BACKEND                │
    │    SRT      │────▶│  ┌─────────┐    ┌───────────────┐   │
    │  (Entrada)  │     │  │ FFmpeg  │───▶│  HLS Output   │   │
    └─────────────┘     │  └────┬────┘    └───────────────┘   │
                        │       │                  │          │
                        │       ▼                  │          │
                        │  ┌─────────┐             │          │
                        │  │ Frames  │             │          │
                        │  └────┬────┘             │          │
                        │       │                  │          │
                        │       ▼                  │          │
                        │  ┌─────────────────┐     │          │
                        │  │   MODELOS IA    │     │          │
                        │  │ ┌─────────────┐ │     │          │
                        │  │ │ Vídeo(Odin) │ │     │          │
                        │  │ ├─────────────┤ │     │          │
                        │  │ │Áudio(Heimd.)│ │     │          │
                        │  │ ├─────────────┤ │     │          │
                        │  │ │Lipsync(Sync)│ │     │          │
                        │  │ └─────────────┘ │     │          │
                        │  └────────┬────────┘     │          │
                        │           │              │          │
                        │           ▼              │          │
                        │  ┌─────────────────┐     │          │
                        │  │  Ocorrências    │     │          │
                        │  │  (Detecções)    │     │          │
                        │  └────────┬────────┘     │          │
                        │           │              │          │
                        └───────────┼──────────────┼──────────┘
                                    │              │
                    ┌───────────────┘              │
                    │                              │
                    ▼                              ▼
    ┌───────────────────────────────────────────────────────────┐
    │                        FRONTEND                           │
    │  ┌─────────────┐  ┌──────────────┐  ┌──────────────────┐  │
    │  │   Player    │  │   Alertas    │  │     Gráficos     │  │
    │  │    HLS      │  │  WebSocket   │  │    ApexCharts    │  │
    │  └─────────────┘  └──────────────┘  └──────────────────┘  │
    └───────────────────────────────────────────────────────────┘


================================================================================
TÓPICO 3: DESAFIOS ENFRENTADOS NA APLICAÇÃO
================================================================================

------------------------------------------------------------------------------
3.1 DESAFIOS TÉCNICOS DE STREAMING
------------------------------------------------------------------------------

DESAFIO: Streams SRT Instáveis
    
    PROBLEMA:
    • Streams de vídeo ao vivo frequentemente têm perda de pacotes
    • Erros H.264 como "Missing reference picture" causavam crashes
    • Conexões podiam cair e não reconectar automaticamente
    
    SOLUÇÃO IMPLEMENTADA:
    • Uso de flags tolerantes no FFmpeg (-err_detect ignore_err)
    • Flag +discardcorrupt para descartar frames corrompidos
    • Sistema continua funcionando mesmo com erros parciais
    • Logs detalhados para identificar problemas no stream de origem

DESAFIO: Conversão SRT para HLS

    PROBLEMA:
    • O navegador não suporta SRT nativamente
    • Precisava converter em tempo real sem atrasos perceptíveis
    • Manter qualidade do vídeo durante a conversão
    
    SOLUÇÃO IMPLEMENTADA:
    • FFmpeg rodando como processo persistente em background
    • Geração contínua de segmentos .ts e playlist .m3u8
    • Otimização de parâmetros para baixa latência

------------------------------------------------------------------------------
3.2 DESAFIOS DE MACHINE LEARNING
------------------------------------------------------------------------------

DESAFIO: Compatibilidade de Modelos Keras/TensorFlow

    PROBLEMA:
    • Modelos podem ter diferentes formatos de entrada (4D vs 5D)
    • Versões diferentes de TensorFlow/Keras têm APIs diferentes
    • Alguns modelos esperam sequências de frames, outros frame único
    
    SOLUÇÃO IMPLEMENTADA:
    • Detecção automática do formato de entrada do modelo
    • Sistema de buffer deslizante (deque) para sequências temporais
    • Padding inteligente quando não há frames suficientes
    • Código adaptável que funciona com ambos os formatos

DESAFIO: Falsos Positivos na Detecção

    PROBLEMA:
    • IA detectava problemas onde não havia
    • Sensibilidade muito alta causava muitos alertas falsos
    • Diferentes tipos de conteúdo precisavam de diferentes limiares
    
    SOLUÇÃO IMPLEMENTADA:
    • Sistema de votação por múltiplos frames consecutivos
    • Média móvel para suavizar detecções instáveis
    • Limiares configuráveis por classe via variáveis de ambiente
    • Heurísticas complementares (blur, brilho, movimento)

DESAFIO: Lipsync e Detecção de Freeze

    PROBLEMA:
    • Modelo de lipsync detectava "dessincronizado" em vídeos congelados
    • Difícil distinguir "freeze real" de "cena parada intencionalmente"
    
    SOLUÇÃO IMPLEMENTADA:
    • Análise de movimento entre frames consecutivos
    • Lipsync só analisa quando há movimento suficiente
    • Priorização: problemas de vídeo têm precedência sobre áudio

------------------------------------------------------------------------------
3.3 DESAFIOS DE ÁUDIO
------------------------------------------------------------------------------

DESAFIO: Extração de Áudio em Diferentes Ambientes

    PROBLEMA:
    • Librosa falhava em Windows sem backend de áudio configurado
    • Alguns streams não tinham trilha de áudio
    • Erros de áudio causavam crash do sistema inteiro
    
    SOLUÇÃO IMPLEMENTADA:
    • Sistema de fallback: Librosa → FFmpeg subprocess
    • Tratamento gracioso de "sem áudio" (não é erro, é estado válido)
    • Buffer vazio quando não há áudio (sistema continua operando)

DESAFIO: Função de Análise de Áudio Retornando Valores Incorretos

    PROBLEMA:
    • Código esperava 3 valores de retorno, função retornava 4
    • Erro silencioso fazia sistema sempre retornar "normal"
    • Difícil de debugar porque não havia mensagem de erro
    
    SOLUÇÃO IMPLEMENTADA:
    • Correção do unpacking de valores (usar indexação)
    • Logs de debug detalhados em cada etapa
    • Testes de validação para garantir funcionamento correto

------------------------------------------------------------------------------
3.4 DESAFIOS DE PERFORMANCE
------------------------------------------------------------------------------

DESAFIO: Inferência em Tempo Real

    PROBLEMA:
    • Modelos de IA são computacionalmente pesados
    • Processamento precisava acompanhar o ritmo do vídeo
    • CPU sozinha era lenta demais para alguns modelos
    
    SOLUÇÃO IMPLEMENTADA:
    • Uso de modelos TFLite quantizados (menores e mais rápidos)
    • Suporte a GPU quando disponível (CUDA)
    • Taxa de amostragem configurável (não processa todo frame)
    • Processamento assíncrono em background

DESAFIO: Geração de Clips (Race Conditions)

    PROBLEMA:
    • FFmpeg tentava ler frames que ainda estavam sendo escritos
    • Arquivos parcialmente escritos causavam clips corrompidos
    • Erros de "Permission Denied" em arquivos temporários
    
    SOLUÇÃO IMPLEMENTADA:
    • Sistema de snapshot: copia frames antes de processar
    • Diretório temporário isolado para cada clip
    • Limpeza robusta de arquivos após processamento

------------------------------------------------------------------------------
3.5 DESAFIOS DE INTERFACE
------------------------------------------------------------------------------

DESAFIO: Atualização em Tempo Real do Dashboard

    PROBLEMA:
    • Muitos eventos simultâneos travavam a interface
    • WebSocket reconectando causava duplicação de dados
    • Gráficos ficavam lentos com muitos pontos
    
    SOLUÇÃO IMPLEMENTADA:
    • Buffer de eventos com RxJS antes de atualizar UI
    • Lógica de deduplicação no frontend
    • Agregação de dados para gráficos (não mostra todo ponto)

DESAFIO: Player HLS e Latência

    PROBLEMA:
    • Player padrão tinha muita latência (5-10 segundos)
    • Reconexão após queda do stream não era automática
    
    SOLUÇÃO IMPLEMENTADA:
    • Configuração de HLS.js para baixa latência
    • Lógica de reconexão automática no frontend

------------------------------------------------------------------------------
3.6 LIÇÕES APRENDIDAS
------------------------------------------------------------------------------

    ┌─────────────────────────────────────────────────────────────────────┐
    │  1. SEMPRE ter fallbacks para operações que podem falhar           │
    │     → Librosa falha? Usa FFmpeg. Sem áudio? Continua sem crash.    │
    │                                                                     │
    │  2. LOGS detalhados são essenciais para debugging                  │
    │     → Sem logs, é impossível saber onde está o problema            │
    │                                                                     │
    │  3. TESTES de validação evitam regressões                          │
    │     → Rodar testes após cada mudança garante que não quebrou nada  │
    │                                                                     │
    │  4. CONFIGURAÇÃO externa é melhor que valores hardcoded            │
    │     → Variáveis de ambiente permitem ajustes sem recompilar        │
    │                                                                     │
    │  5. TOLERÂNCIA a erros é crucial em sistemas de tempo real         │
    │     → Um erro não pode derrubar o sistema inteiro                  │
    │                                                                     │
    │  6. DOCUMENTAÇÃO economiza tempo no futuro                         │
    │     → Código sem documentação é código que será reescrito          │
    └─────────────────────────────────────────────────────────────────────┘


================================================================================
RESUMO EXECUTIVO
================================================================================

O HORUS AI é um sistema de monitoramento de vídeo que:

    ✓ RECEBE streams de vídeo ao vivo via SRT
    ✓ ANALISA automaticamente com 3 modelos de IA (vídeo, áudio, lipsync)
    ✓ DETECTA problemas como freeze, falta de áudio, dessincronização
    ✓ ALERTA em tempo real via interface web
    ✓ GRAVA clips das ocorrências como evidência

TECNOLOGIAS PRINCIPAIS:
    • Backend: Python + FastAPI + TensorFlow/TFLite
    • Frontend: Angular 19 + ApexCharts + HLS.js
    • Streaming: FFmpeg + SRT + HLS

PRINCIPAIS DESAFIOS SUPERADOS:
    • Streams instáveis → Flags tolerantes no FFmpeg
    • Modelos incompatíveis → Detecção automática de formato
    • Falsos positivos → Sistema de votação e limiares configuráveis
    • Performance → Modelos quantizados e processamento assíncrono

================================================================================
                        FIM DO DOCUMENTO
================================================================================
